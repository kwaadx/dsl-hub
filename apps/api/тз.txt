# 1) Візія та домен

## 1.1 Мета продукту (коротко)

* Користувач у чаті формулює вимоги → агент:

  1. **шукає схожий** pipeline у межах flow і пропонує його; або
  2. **генерує новий** JSON-конфіг (pipeline) за активною DSL-схемою;
  3. робить **self-check** (LLM), далі **hard-validate** (JSON Schema + доменні правила);
  4. зберігає як **нову версію**; за бажанням — **publish** (гарантовано одна опублікована на flow).
* Нові треди стартують з **легкого контексту**: активна схема + активний flow-summary + активний pipeline (без прокрутки всієї історії).
* Усе логовано: `generation_run`, `validation_issue`, `agent_log`, `summary_run`, `context_snapshot`.

## 1.2 Глосарій (коротко)

* **Flow** — проєкт/напрям, унікальний `slug`, набір pipeline-ів та тредів.
* **Thread** — діалог у межах flow; має статуси (`NEW/…/ARCHIVED`) і опціональні `result_pipeline_id`, `context_snapshot_id`.
* **Message** — повідомлення в треді (`role: user|assistant|system|tool`, `format: text|markdown|json|...`, дерево через `parent_id`).
* **Pipeline** — JSON-конфіг (semver `version`, `status`, `is_published`, прив’язка до `schema_def`).
* **SchemaDef** — JSON Schema DSL (semver, статус), керується каналами (`schema_channel`).
* **Summaries** — `flow_summary` (один активний), `thread_summary` (кілька на тред).
* **ContextSnapshot** — фіксація активних артефактів (schema/pipeline/summary) у момент події.
* **Runs** — процесні таблиці: `generation_run`, `summary_run`, `pipeline_upgrade_run`.
* **Logs** — `agent_log` події агента.

---

# 2) Архітектурна «вісь»

* **Backend:** FastAPI (або еквівалент), SQLAlchemy (моделі вже є), Alembic, JSON Schema валідатор, LLM клієнт (спершу мок).
* **Агент:** **LangGraph** як FSM (вузли/ребра), що працює поверх наших сервісів/репозиторіїв.
* **Комунікація:** `POST` для надсилання юзерських повідомлень і запуску агента; **SSE** (`text/event-stream`) для стрімінгу прогресу/відповідей агента у треді.
* **Frontend:** твій існуючий UI (меню flows + чат). Підключаємося інкрементально.

---

# 3) Контракти API (MVP → ростемо)

## 3.1 Технічні службові

* `GET /healthz` → `{"status":"ok"}`
* `GET /version` → `{"app":"dsl-hub","version":"x.y.z"}`

## 3.2 Flows / Threads / Messages

* `GET /flows` →
  `[{ id, slug, name, has_published:boolean, active_version?:string }]`
* `POST /flows` `{ slug, name }` → `201 { id, ... }`
* `POST /flows/{flow_id}/threads` → `201 { id, flow_id, started_at, status:"NEW" }`
  (створює **ContextSnapshot** з активних артефактів)
* `GET /threads/{thread_id}` → метадані треда
* `GET /threads/{thread_id}/messages?limit=50&before=<iso>` → історія
* `POST /threads/{thread_id}/messages`
  `{ role, content, parent_id? }` → `201 { id, created_at }`
  **Примітка:** якщо `role="tool"` → **обов’язково** `tool_name` (і, за політикою, `tool_result`).

## 3.3 Агент

* `POST /threads/{thread_id}/agent/run`
  **Вхід:**
  `{ "user_message": { ... вміст ... }, "options": {"publish": false} }`
  **Вихід (один із):**

  1. **Схожий знайдено**

  ```json
  { "ok": false, "suggestion": {
    "pipeline_id": "<uuid>", "version": "1.1.0", "score": 0.83, "diff": { ... } }
  }
  ```

  2. **Створено валідний draft**

  ```json
  { "ok": true, "pipeline_id":"<uuid>", "version":"1.2.0", "status":"draft" }
  ```

  3. **Помилки**

  ```json
  { "ok": false, "issues": [
    {"path":"/stages/0/name","code":"required","severity":"error","message":"Missing name"}
  ]}
  ```
* **SSE стрім**: `GET /threads/{thread_id}/events` (див. §4)

## 3.4 Pipelines

* `GET /flows/{flow_id}/pipelines?published=1|0` → список версій `{ id, version, status, is_published, created_at }`
* `GET /pipelines/{pipeline_id}` → повний JSON (`content`, `schema_def`, `status`, …)
* `POST /pipelines/{pipeline_id}/publish` → `{ ok:true, flow_id, version, is_published:true }`
  (інваріанта «один published на flow» забезпечується в БД)

## 3.5 Summaries / Context

* `GET /flows/{flow_id}/summary/active` → `{ version, content, last_message_id }`
* `GET /threads/{thread_id}/summaries` → список `{ id, kind, content, covering_* }`
* `POST /threads/{thread_id}/close` → запускає `thread_summary` і оновлює `flow_summary` (is_active=true, version++)

## 3.6 Schemas & Upgrades (базово)

* `GET /schema/channels` → `[{ name, active_schema_def_id, def: { id, name, version } }]`
* `POST /schema/channels/{name}` `{ schema_def_id }` → активувати
* `POST /schema/upgrade-plan` `{ from_schema_def_id, to_schema_def_id, strategy, transform_spec? }`
* `POST /pipelines/{id}/upgrade` `{ upgrade_plan_id }` → створює `pipeline_upgrade_run`
* `GET /pipeline-upgrade-runs?pipeline_id=...`

## 3.7 Єдина модель помилки

```json
{ "error": { "code":"VALIDATION_FAILED", "message":"...", "details":[...] } }
```

## 3.8 Ідемпотентність POST (рекоменд.)

* Заголовок `Idempotency-Key: <uuid>`
* Сервер кешує результат для цього ключа протягом T хв.

---

# 4) SSE: специфіка і поведінка

## 4.1 Ендпоїнт

* `GET /threads/{thread_id}/events` з заголовком:

  * `Accept: text/event-stream`
  * `Cache-Control: no-cache`
  * `Connection: keep-alive`

## 4.2 Формат подій

Кожна подія — `event: <type>\n` + `data: <json>\n\n`.

**Події (мінімальний набір):**

* `run.started` — `{ run_id, stage, ts }`
* `run.stage` — `{ run_id, stage, status, ts, meta? }`
* `run.finished` — `{ run_id, status, ts }`
* `agent.msg` — `{ role:"assistant"|"system"|"tool", format:"text|markdown|json|...", content:{...}, ts }`
* `suggestion` — `{ pipeline_id, version, score, diff? }`
* `issues` — `{ items:[{path, code, severity, message}], ts }`
* `pipeline.created` — `{ pipeline_id, version, status }`
* `pipeline.published` — `{ pipeline_id, version }`

**Keep-alive:** періодично `event: ping` з порожнім `data`.

## 4.3 Відновлення сесії

* Клієнт зберігає `Last-Event-ID` та передає в заголовку `Last-Event-ID` при реконекті.
* Сервер з буфера відправляє пропущені події або повертає 204 і просить перепідключення без `Last-Event-ID`.

## 4.4 Клієнт (фронт)

```js
const es = new EventSource(`/threads/${id}/events`);
es.addEventListener('run.stage', e => { const payload = JSON.parse(e.data); /* render */ });
es.addEventListener('agent.msg', e => { /* append bubble */ });
es.addEventListener('issues', e => { /* show list */ });
```

---

# 5) Агент на LangGraph (FSM)

## 5.1 Стан (`State`)

```ts
type State = {
  flow_id: UUID
  thread_id: UUID
  user_message: any           // payload з POST
  context: {
    schema_def: JSON
    flow_summary?: JSON
    active_pipeline?: JSON
  }
  candidate?: { pipeline_id: UUID, version: string, score: number, diff?: any }
  draft?: JSON                // проект pipeline
  notes?: JSON                // self-check result
  issues?: Issue[]            // validation issues
  persisted?: { pipeline_id: UUID, version: string }
  options?: { publish?: boolean }
  run_id: UUID                // generation_run.id
}
```

## 5.2 Вузли графа (nodes)

1. **init**

   * створити `generation_run` (stage=`discovery`, status=`running`)
   * зібрати `context` (active schema_def, flow_summary, active pipeline)
   * SSE: `run.started`
2. **search_existing**

   * TRGM по `pipeline.content_text` + (опц.) `content_hash` exact; скоринг
   * якщо `score >= threshold` → `candidate` set & emit `suggestion` (SSE), перехід у **decide_after_suggestion**
   * інакше → **generate**
3. **decide_after_suggestion**

   * якщо клієнт підтверджує “Use as base / Modify” у наступному POST, це окремий сценарій (MVP: повертаємо у відповідь suggestion і зупиняємо run зі статусом `succeeded`).
   * Інакше — продовжуємо до **generate**.
4. **generate**

   * LLM: `generate_pipeline(context)` → `draft`
   * SSE: `run.stage` (stage=`generate`, status=`succeeded`) + `agent.msg` (assistant: короткий коментар)
5. **self_check**

   * LLM: `self_check(draft)` → `notes`
   * SSE: `run.stage` (`self_check`, `succeeded`), `agent.msg` (assistant summary/notes)
6. **hard_validate**

   * JSON Schema (`schema_def.json`) + доменні правила → `issues[]`
   * якщо `issues` → SSE: `issues`; завершити run (`failed`) і **зупинитись**
   * якщо ок → далі **persist**
7. **persist**

   * створити нову версію: `PipelineService.create_version(flow_id, draft, schema_def_id)`
   * SSE: `pipeline.created`
   * якщо `options.publish===true` → **publish** інакше **finish**
8. **publish**

   * `PipelineService.publish(pipeline_id)` (гарантовано одна published)
   * SSE: `pipeline.published`
9. **finish**

   * SSE: `run.finished` (status=`succeeded`)
   * Повернути відповідь API (`ok:true`).

## 5.3 Ребра (умови переходів)

* `init → search_existing` (завжди)
* `search_existing → decide_after_suggestion` (якщо знайдено `candidate`)
* `search_existing → generate` (інакше)
* `decide_after_suggestion → [stop or generate]` (MVP: stop з відповіді API)
* `generate → self_check`
* `self_check → hard_validate`
* `hard_validate → finish` (якщо issues), `… → persist` (якщо ок)
* `persist → publish? → finish`

## 5.4 Логування у `generation_run`

* На кожному вузлі: `runs.tick(run_id, stage, status, started_at/finished_at, result?)`
* На кінці: `runs.finish(run_id, status)`

---

# 6) Перевірки та інваріанти (важливо!)

## 6.1 На рівні БД (вже є)

* **SemVer:** `schema_def.version`, `pipeline.version`, `pipeline.schema_version` (`^\d+\.\d+\.\d+$`).
* **Публікація:** `pipeline.is_published ↔ status='published'` + partial-UNIQUE «один published на flow».
* **Стани:** CHECK на `thread.status`, `message.role/format`, `generation_run.status/stage`, `summary_run`, `validation_issue.severity`, `agent_log.level`, тощо.
* **Час:** `*_ts_order_ck` — `started_at/finished_at` ≥ логічні межі; `thread.closed_at ≥ started_at`.
* **Same-flow цілісність:** тригери `*_same_flow()` для `flow_summary.last_message_id`, `context_snapshot`, `generation_run`, `summary_run`, **thread.result_pipeline_id**, **thread.context_snapshot_id**.
* **Message tree:** тригер `message_parent_same_thread()` + `message_parent_idx`.
* **JSON типи:** `jsonb_typeof(...)='object'` в потрібних місцях (runs.cost/result/source, summaries.pinned, snapshot.notes, upgrade_run.diff/issues).
* **Архівування тредів:** `set_archived_ts()`.

## 6.2 На рівні застосунку (сервіси)

* **ThreadService.create**: створює `ContextSnapshot` (active schema/pipeline/flow_summary), перевіряє їх узгодженість по flow (хоч БД і перевіряє).
* **MessageService.add**:

  * валідність `role`, `format` з білої списку (дублюємо CHECK для красивих помилок API);
  * якщо `role="tool"` → `tool_name` (і за політикою `tool_result`);
  * `parent_id` має належати **цьому** треду (БД теж це ловить тригером).
* **PipelineService.create_version**:

  * **Синхронізація** `schema_version` з обраним `schema_def_id` (у БД тригер робить це завжди);
  * **Генерація** `version` (semver bump) — політика нижче;
  * **optionally** `content_hash = sha256(canonical_json(content))`.
* **PipelineService.publish**:

  * транзакція: зняти publish зі старого → виставити новому;
  * у випадку конкурентної гонки — 409 CONFLICT (БД гарантує інваріанту).
* **ValidationService.validate**:

  * JSON Schema + доменні: унікальність ідентифікаторів, допустимі enum, перетини масивів, обов’язкові поля.
  * Повертає список `issues` c `path/code/severity/message`.
* **SimilarityService**:

  * TRGM по `pipeline.content_text` (нормований JSON у текст) → скоринг (0..1);
  * Якщо є `content_hash` → exact match пріоритетніше;
  * Поріг `threshold` (0.7–0.8, конфігурований).

---

# 7) Правила версіонування

## 7.1 `pipeline.version` (semver)

* **patch**: несуттєві зміни (параметри, не змінюють контрактів).
* **minor**: нові можливості, назад сумісні.
* **major**: несумісні або **перехід на іншу `schema_def`** (можна підвищувати major при міграції).

## 7.2 `pipeline.schema_version`

* **Автоматично** синхронізується з `schema_def.version` (тригер у БД).
* У сервісі заборонити ручні відмінності.

---

# 8) Ланцюжок «Новий тред → робота агента»

1. **Користувач** у фронті обирає flow → натискає «New Thread».
2. **Backend:**

   * `ThreadService.create(flow_id)`
   * створює `ContextSnapshot` із: активної `schema_def` (з `schema_channel`), активного `flow_summary`, активного `pipeline`.
   * повертає `{id, status:NEW,...}`.
3. **Фронт** відкриває чат треда, підписується на `/threads/{id}/events` (SSE).
4. **Юзер** надсилає перше повідомлення: `POST /threads/{id}/messages` і **одразу** `POST /threads/{id}/agent/run`.
5. **Агент (LangGraph):** стрімить стадії/повідомлення в SSE (див. §4, §5), завершує з suggestion / draft / issues.
6. **Юзер** обирає опублікувати або продовжити дискусію (нове повідомлення → новий run або уточнення вимог).
7. **Закриття треда:** `POST /threads/{id}/close` → генерує `thread_summary`, оновлює `flow_summary` (is_active=true, version++).

---

# 9) Prompt Templates (міні-ТЗ для вмісту)

У БД `prompt_template` — мінімум:

* **generate**: інструкція → «ти автор DSL-pipeline», **вхід:**

  * `schema_def.json`,
  * `flow_summary.content` (якщо є),
  * `active_pipeline.content` (як референс, якщо є),
  * `user_message`.
    **вихід:** **валідний JSON** без зайвого тексту (додаємо «відповідай чистим JSON»).
* **self_check**: аналізує draft → повертає список нотаток/ризиків/відсутніх полів (JSON).
* **hard_validate**: (не промпт, це наш валідатор), але можна мати `prompt` для пояснювального тексту користувачеві.
* **summarize**: робить `thread_summary`/`flow_summary` коротким, маркованим, без історичного шуму.
* **migrate**: мапінг `from_schema` → `to_schema` (для `schema_upgrade_plan.strategy='transform'`).

---

# 10) Потік SSE + POST (UX-поведінка)

* Після `POST /threads/{id}/agent/run` фронт **нічого не блокує**: продовжує слухати SSE.
* Події приходять у такій типовій послідовності:

  1. `run.started` (stage=discovery)
  2. `run.stage` (stage=search_existing → succeeded)
     *може з’явитись* `suggestion`
  3. якщо нема кандидата: `run.stage` (generate → succeeded) + `agent.msg` (короткий опис)
  4. `run.stage` (self_check → succeeded) + `agent.msg` (поради)
  5. `run.stage` (hard_validate → failed) + `issues` **АБО** (… → succeeded) і `pipeline.created`
  6. (опційно) `pipeline.published`
  7. `run.finished`

---

# 11) Тести (must-have)

* **Unit (репо/сервіси):**
  CRUD, `ThreadService.create` (context snapshot), `PipelineService.publish`, `ValidationService.validate`.
* **FSM (агент):**
  3 сценарії: suggestion / success / failed (issues). Перевірка SSE-шинки (події йдуть у правильній послідовності).
* **API-контракт:**
  усі маршрути з позитивними та негативними кейсами (перевірки ролей/форматів/JSON-типів).
* **E2E:**
  flow → thread → message → agent.run → (suggestion|draft|issues) → publish → close thread → summaries.
* **Performance sanity:**
  TRGM пошук по pipelines на 10–50k записів (LAT < 200–300ms); SSE стабільність (reconnect).

---

# 12) Міграції/деплой/конфіг

* Alembic `upgrade head` на старті.
* ENV:
  `DATABASE_URL`, `LLM_PROVIDER`, `LLM_API_KEY`, `LLM_TIMEOUT`, `SIMILARITY_THRESHOLD`, `SSE_PING_INTERVAL`, `MAX_JSON_SIZE`.
* Docker Compose: `db + api (+ worker за потреби)`.
* `seed.py`: створює `schema_def v1.0.0`, `schema_channel stable`, базові `prompt_template`.

---

# 13) Безпека / експлуатація (MVP)

* Token-based auth (на рівні reverse proxy або FastAPI Depends) — мінімум.
* Логи: `agent_log` + структуровані application-логи (json).
* Метрики: кількість run-ів, успіх/фейл, latency по стадіях, довжина SSE сесій.
* Ліміти: розмір `POST` тіла; таймаути LLM; ретраї з backoff.
* Кеш ідемпотентності для `POST` (опціонально).

---

# 14) Поетапний план робіт (узгоджений з твоїм UI)

## M0 — фундамент (1–2 дні)

* Alembic up + seed, `/healthz`, `/version`.
  **Фронт:** індикатор онлайн.

## M1 — базові CRUD + чат без агента (1–2 дні)

* Flows/Threads/Messages ендпоїнти.
  **Фронт:** ліва панель flows; new thread; перегляд/надсилання повідомлень.

## M2 — Агент (LangGraph) + SSE (4–6 днів)

* Реалізувати FSM вузли: init, search_existing, generate, self_check, hard_validate, persist, publish, finish.
* `POST /threads/{id}/agent/run` + `GET /threads/{id}/events` (SSE).
* Мок LLM (щоб демо працювало без ключів).
  **Фронт:** після сабміту викликати `agent/run`, слухати SSE, рендерити події.

## M3 — Версії та публікація (1–2 дні)

* `GET /flows/{id}/pipelines`, `GET /pipelines/{id}`, `POST /pipelines/{id}/publish`.
  **Фронт:** “Active pipeline” + “Versions”, кнопка Publish.

## M4 — Саммері та закриття тредів (2–3 дні)

* `POST /threads/{id}/close`, `GET /flows/{id}/summary/active`, `GET /threads/{id}/summaries`.
  **Фронт:** панель “Flow context”, без підвантаження історії для нового треда.

## M5 — Схеми та апґрейди (3–5 днів)

* Канали схем, плани апґрейду, запуск `pipeline_upgrade_run`.
  **Фронт:** вкладка “Schema & Upgrades”.

## M6 — Полірування (безпека/метрики/ідемпотентність) (2–4 дні)

* Єдина модель помилок, ліміти, метрики, retry/backoff для LLM, покриття тестами.

---

# 15) Тонкі нюанси (щоб не загубилися)

* **Один published**: інваріанта гарантується БД (partial unique). У коді робимо транзакцію «старий off → новий on», 409 при конфліктах.
* **schema_version**: **не дозволяти** руками; завжди з `schema_def.version` (БД тригер і код сервісу).
* **parent_id**: завжди того ж треда (БД тригер ловить; у коді робимо дружню помилку).
* **role='tool'**: вимагати `tool_name` (і, якщо policy=on, `tool_result`).
* **ContextSnapshot**: робимо при **створенні** треда; можна робити додаткові перед publish.
* **Similarity**: нормалізуємо JSON для TRGM/хешу (канонічне сортування ключів).
* **SSE стабільність**: heartbeat `ping` раз на ~15–20с; підтримка `Last-Event-ID` за змогою.
* **Валідація JSON**: чіткі коди (`required`, `enum`, `duplicate_id`, `range`, `cross_field`) і зрозумілі `path`.
* **SemVer bump**: документуємо політику (див. §7); при міграції схеми — зазвичай **major**.
* **Runs**: кожен вузол графа відмічає `stage` і `status`; `cost` пишемо, коли є LLM; `error` — текст/код.
* **Завершення треда**: робимо `thread_summary` і оновлюємо `flow_summary` (is_active=true), щоб нові треди стартували легко.
