from __future__ import annotations

from typing import Protocol, Iterable, Optional, Any
from .entities import ThreadEntity, MessageEntity

class ThreadRepo(Protocol):
    def get(self, thread_id: str) -> Optional[ThreadEntity]: ...
    def create_if_missing(self, thread_id: str, flow_id: str) -> ThreadEntity: ...

class MessageRepo(Protocol):
    def add(self, *, message_id: str, thread_id: str, role: str, content: Any, 
            parent_id: Optional[str], tool_name: Optional[str], tool_result: Optional[Any], fmt: str) -> MessageEntity: ...
    def list_for_thread(self, thread_id: str, limit: int = 50) -> Iterable[MessageEntity]: ...
    def list_window(self, thread_id: str, before: Optional[str], limit: int) -> Iterable[MessageEntity]: ...

class LLMClient(Protocol):
    async def chat(self, messages: list[dict], *, timeout: int | None = None) -> dict: ...

class SimilarityClient(Protocol):
    def score(self, a: str, b: str) -> float: ...

class SchemaRepo(Protocol):
    def get_active_schema(self, channel: str) -> dict | None: ...


class FlowRepo(Protocol):
    def get(self, flow_id: str) -> Optional[dict]: ...
    def create(self, name: str, slug: Optional[str]) -> dict: ...
    def update(self, flow_id: str, *, name: Optional[str], slug: Optional[str]) -> dict: ...
    def delete(self, flow_id: str) -> bool: ...
    def list(self, limit: int = 100, offset: int = 0) -> Iterable[dict]: ...
    def get_by_slug(self, slug: str) -> Optional[dict]: ...

class PipelineRepo(Protocol):
    def get(self, pipeline_id: str) -> Optional[dict]: ...
    def create(self, flow_id: str, payload: dict) -> dict: ...
    def list_for_flow(self, flow_id: str, limit: int = 100, offset: int = 0) -> Iterable[dict]: ...

class ThreadSummaryRepo(Protocol):
    def list_for_thread(self, thread_id: str) -> Iterable[dict]: ...
    def create(self, thread_id: str, kind: str, content: dict, token_budget: int, covering_from, covering_to) -> dict: ...


class RunsRepo(Protocol):
    def create(self, thread_id: str, run_id: str, status: str, meta: dict) -> None: ...
    def update_status(self, run_id: str, status: str, meta: dict | None = None) -> None: ...
    def get(self, run_id: str) -> dict | None: ...

class PipelineServicePort(Protocol):
    def get_active_for_flow(self, flow_id: str) -> dict | None: ...
    def compile(self, pipeline: dict) -> dict: ...

class ValidationServicePort(Protocol):
    def validate(self, channel: str, payload: dict) -> dict: ...



class SummarizerPort(Protocol):
    async def summarize_thread(self, messages: list[dict], *, kind: str = "short") -> dict: ...
    async def summarize_flow(self, thread_summaries: list[dict]) -> dict: ...


class FlowSummaryRepo(Protocol):
    def get_active(self, flow_id: str) -> dict | None: ...
    def upsert_active(self, flow_id: str, *, content: dict, last_message_id: str | None) -> dict: ...


class EventBusPort(Protocol):
    def publish(self, data: dict, *, channel: str | None = None) -> None: ...

class PromptTemplateRepo(Protocol):
    def get_active(self, key: str) -> dict | None: ...
    def get(self, key: str, version: int) -> dict | None: ...
    def list(self, key: str) -> Iterable[dict]: ...
    def upsert(self, key: str, version: int, content: dict, is_active: bool = True) -> dict: ...

class CompatRuleRepo(Protocol):
    def list_for_subject(self, subject_kind: str, subject_key: str, subject_version: str) -> Iterable[dict]: ...

class AgentLogRepo(Protocol):
    def write(self, run_id: str, thread_id: str, flow_id: str, step: str, level: str, message: str, data: dict | None = None) -> None: ...
